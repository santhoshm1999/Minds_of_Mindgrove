//
// Generated by Bluespec Compiler, version untagged-g2930c314 (build 2930c314)
//
// On Tue Nov 26 00:46:42 IST 2024
//
//
// Ports:
// Name                         I/O  size props
// RDY_get_fl_a                   O     1
// RDY_get_fl_b                   O     1
// RDY_get_fl_c                   O     1
// RDY_get_s1_or_s2               O     1 const
// get_end_res                    O    32 reg
// RDY_get_end_res                O     1 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
// get_fl_a_a                     I    16 reg
// get_fl_b_b                     I    16 reg
// get_fl_c_b                     I    32 reg
// get_s1_or_s2_s1_s2             I     1 reg
// EN_get_fl_a                    I     1
// EN_get_fl_b                    I     1
// EN_get_fl_c                    I     1
// EN_get_s1_or_s2                I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkMAC(CLK,
	     RST_N,

	     get_fl_a_a,
	     EN_get_fl_a,
	     RDY_get_fl_a,

	     get_fl_b_b,
	     EN_get_fl_b,
	     RDY_get_fl_b,

	     get_fl_c_b,
	     EN_get_fl_c,
	     RDY_get_fl_c,

	     get_s1_or_s2_s1_s2,
	     EN_get_s1_or_s2,
	     RDY_get_s1_or_s2,

	     get_end_res,
	     RDY_get_end_res);
  input  CLK;
  input  RST_N;

  // action method get_fl_a
  input  [15 : 0] get_fl_a_a;
  input  EN_get_fl_a;
  output RDY_get_fl_a;

  // action method get_fl_b
  input  [15 : 0] get_fl_b_b;
  input  EN_get_fl_b;
  output RDY_get_fl_b;

  // action method get_fl_c
  input  [31 : 0] get_fl_c_b;
  input  EN_get_fl_c;
  output RDY_get_fl_c;

  // action method get_s1_or_s2
  input  get_s1_or_s2_s1_s2;
  input  EN_get_s1_or_s2;
  output RDY_get_s1_or_s2;

  // value method get_end_res
  output [31 : 0] get_end_res;
  output RDY_get_end_res;

  // signals for module outputs
  wire [31 : 0] get_end_res;
  wire RDY_get_end_res,
       RDY_get_fl_a,
       RDY_get_fl_b,
       RDY_get_fl_c,
       RDY_get_s1_or_s2;

  // register end_res
  reg [31 : 0] end_res;
  wire [31 : 0] end_res_D_IN;
  wire end_res_EN;

  // register end_res_done
  reg end_res_done;
  wire end_res_done_D_IN, end_res_done_EN;

  // register fl_a
  reg [15 : 0] fl_a;
  wire [15 : 0] fl_a_D_IN;
  wire fl_a_EN;

  // register fl_b
  reg [15 : 0] fl_b;
  wire [15 : 0] fl_b_D_IN;
  wire fl_b_EN;

  // register fl_c
  reg [31 : 0] fl_c;
  wire [31 : 0] fl_c_D_IN;
  wire fl_c_EN;

  // register fl_res
  reg [31 : 0] fl_res;
  wire [31 : 0] fl_res_D_IN;
  wire fl_res_EN;

  // register float_inp_done
  reg float_inp_done;
  wire float_inp_done_D_IN, float_inp_done_EN;

  // register got_a
  reg got_a;
  wire got_a_D_IN, got_a_EN;

  // register got_b
  reg got_b;
  wire got_b_D_IN, got_b_EN;

  // register got_c
  reg got_c;
  wire got_c_D_IN, got_c_EN;

  // register got_si
  reg got_si;
  wire got_si_D_IN, got_si_EN;

  // register int_a
  reg [15 : 0] int_a;
  wire [15 : 0] int_a_D_IN;
  wire int_a_EN;

  // register int_b
  reg [15 : 0] int_b;
  wire [15 : 0] int_b_D_IN;
  wire int_b_EN;

  // register int_c
  reg [31 : 0] int_c;
  wire [31 : 0] int_c_D_IN;
  wire int_c_EN;

  // register int_res
  reg [31 : 0] int_res;
  wire [31 : 0] int_res_D_IN;
  wire int_res_EN;

  // register s1_or_s2
  reg s1_or_s2;
  wire s1_or_s2_D_IN, s1_or_s2_EN;

  // ports of submodule float_mac
  wire [31 : 0] float_mac_get_MAC_result, float_mac_get_input_c_c;
  wire [15 : 0] float_mac_get_input_a_a, float_mac_get_input_b_b;
  wire float_mac_EN_get_input_a,
       float_mac_EN_get_input_b,
       float_mac_EN_get_input_c,
       float_mac_EN_get_input_s,
       float_mac_RDY_get_MAC_result,
       float_mac_RDY_get_input_a,
       float_mac_RDY_get_input_b,
       float_mac_RDY_get_input_c;

  // ports of submodule int_mac
  wire [31 : 0] int_mac_get_C_c, int_mac_get_output;
  wire [15 : 0] int_mac_get_A_a, int_mac_get_B_b;
  wire int_mac_EN_get_A,
       int_mac_EN_get_B,
       int_mac_EN_get_C,
       int_mac_EN_get_select,
       int_mac_get_select_select;

  // rule scheduling signals
  wire CAN_FIRE_RL_deasdrt_signal,
       CAN_FIRE_RL_rl_get_float_res,
       CAN_FIRE_RL_rl_put_float_val,
       CAN_FIRE_get_fl_a,
       CAN_FIRE_get_fl_b,
       CAN_FIRE_get_fl_c,
       CAN_FIRE_get_s1_or_s2,
       WILL_FIRE_RL_deasdrt_signal,
       WILL_FIRE_RL_rl_get_float_res,
       WILL_FIRE_RL_rl_put_float_val,
       WILL_FIRE_get_fl_a,
       WILL_FIRE_get_fl_b,
       WILL_FIRE_get_fl_c,
       WILL_FIRE_get_s1_or_s2;

  // inputs to muxes for submodule ports
  wire MUX_got_a_write_1__SEL_1;

  // action method get_fl_a
  assign RDY_get_fl_a = !got_a ;
  assign CAN_FIRE_get_fl_a = !got_a ;
  assign WILL_FIRE_get_fl_a = EN_get_fl_a ;

  // action method get_fl_b
  assign RDY_get_fl_b = !got_b ;
  assign CAN_FIRE_get_fl_b = !got_b ;
  assign WILL_FIRE_get_fl_b = EN_get_fl_b ;

  // action method get_fl_c
  assign RDY_get_fl_c = !got_c ;
  assign CAN_FIRE_get_fl_c = !got_c ;
  assign WILL_FIRE_get_fl_c = EN_get_fl_c ;

  // action method get_s1_or_s2
  assign RDY_get_s1_or_s2 = 1'd1 ;
  assign CAN_FIRE_get_s1_or_s2 = 1'd1 ;
  assign WILL_FIRE_get_s1_or_s2 = EN_get_s1_or_s2 ;

  // value method get_end_res
  assign get_end_res = end_res ;
  assign RDY_get_end_res = end_res_done ;

  // submodule float_mac
  mkUnpipelined_float float_mac(.CLK(CLK),
				.RST_N(RST_N),
				.get_input_a_a(float_mac_get_input_a_a),
				.get_input_b_b(float_mac_get_input_b_b),
				.get_input_c_c(float_mac_get_input_c_c),
				.EN_get_input_a(float_mac_EN_get_input_a),
				.EN_get_input_b(float_mac_EN_get_input_b),
				.EN_get_input_s(float_mac_EN_get_input_s),
				.EN_get_input_c(float_mac_EN_get_input_c),
				.RDY_get_input_a(float_mac_RDY_get_input_a),
				.RDY_get_input_b(float_mac_RDY_get_input_b),
				.RDY_get_input_s(),
				.RDY_get_input_c(float_mac_RDY_get_input_c),
				.get_MAC_result(float_mac_get_MAC_result),
				.RDY_get_MAC_result(float_mac_RDY_get_MAC_result));

  // submodule int_mac
  mkintmul int_mac(.CLK(CLK),
		   .RST_N(RST_N),
		   .get_A_a(int_mac_get_A_a),
		   .get_B_b(int_mac_get_B_b),
		   .get_C_c(int_mac_get_C_c),
		   .get_select_select(int_mac_get_select_select),
		   .EN_get_A(int_mac_EN_get_A),
		   .EN_get_B(int_mac_EN_get_B),
		   .EN_get_C(int_mac_EN_get_C),
		   .EN_get_select(int_mac_EN_get_select),
		   .RDY_get_A(),
		   .RDY_get_B(),
		   .RDY_get_C(),
		   .RDY_get_select(),
		   .get_output(int_mac_get_output),
		   .RDY_get_output());

  // rule RL_rl_get_float_res
  assign CAN_FIRE_RL_rl_get_float_res =
	     float_mac_RDY_get_MAC_result && float_inp_done && !end_res_done ;
  assign WILL_FIRE_RL_rl_get_float_res = CAN_FIRE_RL_rl_get_float_res ;

  // rule RL_rl_put_float_val
  assign CAN_FIRE_RL_rl_put_float_val =
	     float_mac_RDY_get_input_c && float_mac_RDY_get_input_b &&
	     float_mac_RDY_get_input_a &&
	     got_si &&
	     got_a &&
	     got_b &&
	     got_c &&
	     !float_inp_done ;
  assign WILL_FIRE_RL_rl_put_float_val = CAN_FIRE_RL_rl_put_float_val ;

  // rule RL_deasdrt_signal
  assign CAN_FIRE_RL_deasdrt_signal = MUX_got_a_write_1__SEL_1 ;
  assign WILL_FIRE_RL_deasdrt_signal = MUX_got_a_write_1__SEL_1 ;

  // inputs to muxes for submodule ports
  assign MUX_got_a_write_1__SEL_1 = float_inp_done && end_res_done ;

  // register end_res
  assign end_res_D_IN =
	     s1_or_s2 ? float_mac_get_MAC_result : int_mac_get_output ;
  assign end_res_EN = CAN_FIRE_RL_rl_get_float_res ;

  // register end_res_done
  assign end_res_done_D_IN = !WILL_FIRE_RL_deasdrt_signal ;
  assign end_res_done_EN =
	     WILL_FIRE_RL_deasdrt_signal || WILL_FIRE_RL_rl_get_float_res ;

  // register fl_a
  assign fl_a_D_IN = get_fl_a_a ;
  assign fl_a_EN = EN_get_fl_a ;

  // register fl_b
  assign fl_b_D_IN = get_fl_b_b ;
  assign fl_b_EN = EN_get_fl_b ;

  // register fl_c
  assign fl_c_D_IN = get_fl_c_b ;
  assign fl_c_EN = EN_get_fl_c ;

  // register fl_res
  assign fl_res_D_IN = 32'h0 ;
  assign fl_res_EN = 1'b0 ;

  // register float_inp_done
  assign float_inp_done_D_IN = !WILL_FIRE_RL_deasdrt_signal ;
  assign float_inp_done_EN =
	     WILL_FIRE_RL_deasdrt_signal || WILL_FIRE_RL_rl_put_float_val ;

  // register got_a
  assign got_a_D_IN = !WILL_FIRE_RL_deasdrt_signal ;
  assign got_a_EN = WILL_FIRE_RL_deasdrt_signal || EN_get_fl_a ;

  // register got_b
  assign got_b_D_IN = !WILL_FIRE_RL_deasdrt_signal ;
  assign got_b_EN = WILL_FIRE_RL_deasdrt_signal || EN_get_fl_b ;

  // register got_c
  assign got_c_D_IN = !WILL_FIRE_RL_deasdrt_signal ;
  assign got_c_EN = WILL_FIRE_RL_deasdrt_signal || EN_get_fl_c ;

  // register got_si
  assign got_si_D_IN = !WILL_FIRE_RL_deasdrt_signal ;
  assign got_si_EN = WILL_FIRE_RL_deasdrt_signal || EN_get_s1_or_s2 ;

  // register int_a
  assign int_a_D_IN = 16'h0 ;
  assign int_a_EN = 1'b0 ;

  // register int_b
  assign int_b_D_IN = 16'h0 ;
  assign int_b_EN = 1'b0 ;

  // register int_c
  assign int_c_D_IN = 32'h0 ;
  assign int_c_EN = 1'b0 ;

  // register int_res
  assign int_res_D_IN = 32'h0 ;
  assign int_res_EN = 1'b0 ;

  // register s1_or_s2
  assign s1_or_s2_D_IN = get_s1_or_s2_s1_s2 ;
  assign s1_or_s2_EN = EN_get_s1_or_s2 ;

  // submodule float_mac
  assign float_mac_get_input_a_a = fl_a ;
  assign float_mac_get_input_b_b = fl_b ;
  assign float_mac_get_input_c_c = fl_c ;
  assign float_mac_EN_get_input_a =
	     WILL_FIRE_RL_rl_put_float_val && s1_or_s2 ;
  assign float_mac_EN_get_input_b =
	     WILL_FIRE_RL_rl_put_float_val && s1_or_s2 ;
  assign float_mac_EN_get_input_s = 1'b0 ;
  assign float_mac_EN_get_input_c =
	     WILL_FIRE_RL_rl_put_float_val && s1_or_s2 ;

  // submodule int_mac
  assign int_mac_get_A_a = fl_a ;
  assign int_mac_get_B_b = fl_b ;
  assign int_mac_get_C_c = fl_c ;
  assign int_mac_get_select_select = 1'b0 ;
  assign int_mac_EN_get_A = WILL_FIRE_RL_rl_put_float_val && !s1_or_s2 ;
  assign int_mac_EN_get_B = WILL_FIRE_RL_rl_put_float_val && !s1_or_s2 ;
  assign int_mac_EN_get_C = WILL_FIRE_RL_rl_put_float_val && !s1_or_s2 ;
  assign int_mac_EN_get_select = 1'b0 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        end_res <= `BSV_ASSIGNMENT_DELAY 32'd0;
	end_res_done <= `BSV_ASSIGNMENT_DELAY 1'd0;
	fl_a <= `BSV_ASSIGNMENT_DELAY 16'd0;
	fl_b <= `BSV_ASSIGNMENT_DELAY 16'd0;
	fl_c <= `BSV_ASSIGNMENT_DELAY 32'd0;
	fl_res <= `BSV_ASSIGNMENT_DELAY 32'd0;
	float_inp_done <= `BSV_ASSIGNMENT_DELAY 1'd0;
	got_a <= `BSV_ASSIGNMENT_DELAY 1'd0;
	got_b <= `BSV_ASSIGNMENT_DELAY 1'd0;
	got_c <= `BSV_ASSIGNMENT_DELAY 1'd0;
	got_si <= `BSV_ASSIGNMENT_DELAY 1'd0;
	int_a <= `BSV_ASSIGNMENT_DELAY 16'd0;
	int_b <= `BSV_ASSIGNMENT_DELAY 16'd0;
	int_c <= `BSV_ASSIGNMENT_DELAY 32'd0;
	int_res <= `BSV_ASSIGNMENT_DELAY 32'd0;
	s1_or_s2 <= `BSV_ASSIGNMENT_DELAY 1'b0;
      end
    else
      begin
        if (end_res_EN) end_res <= `BSV_ASSIGNMENT_DELAY end_res_D_IN;
	if (end_res_done_EN)
	  end_res_done <= `BSV_ASSIGNMENT_DELAY end_res_done_D_IN;
	if (fl_a_EN) fl_a <= `BSV_ASSIGNMENT_DELAY fl_a_D_IN;
	if (fl_b_EN) fl_b <= `BSV_ASSIGNMENT_DELAY fl_b_D_IN;
	if (fl_c_EN) fl_c <= `BSV_ASSIGNMENT_DELAY fl_c_D_IN;
	if (fl_res_EN) fl_res <= `BSV_ASSIGNMENT_DELAY fl_res_D_IN;
	if (float_inp_done_EN)
	  float_inp_done <= `BSV_ASSIGNMENT_DELAY float_inp_done_D_IN;
	if (got_a_EN) got_a <= `BSV_ASSIGNMENT_DELAY got_a_D_IN;
	if (got_b_EN) got_b <= `BSV_ASSIGNMENT_DELAY got_b_D_IN;
	if (got_c_EN) got_c <= `BSV_ASSIGNMENT_DELAY got_c_D_IN;
	if (got_si_EN) got_si <= `BSV_ASSIGNMENT_DELAY got_si_D_IN;
	if (int_a_EN) int_a <= `BSV_ASSIGNMENT_DELAY int_a_D_IN;
	if (int_b_EN) int_b <= `BSV_ASSIGNMENT_DELAY int_b_D_IN;
	if (int_c_EN) int_c <= `BSV_ASSIGNMENT_DELAY int_c_D_IN;
	if (int_res_EN) int_res <= `BSV_ASSIGNMENT_DELAY int_res_D_IN;
	if (s1_or_s2_EN) s1_or_s2 <= `BSV_ASSIGNMENT_DELAY s1_or_s2_D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    end_res = 32'hAAAAAAAA;
    end_res_done = 1'h0;
    fl_a = 16'hAAAA;
    fl_b = 16'hAAAA;
    fl_c = 32'hAAAAAAAA;
    fl_res = 32'hAAAAAAAA;
    float_inp_done = 1'h0;
    got_a = 1'h0;
    got_b = 1'h0;
    got_c = 1'h0;
    got_si = 1'h0;
    int_a = 16'hAAAA;
    int_b = 16'hAAAA;
    int_c = 32'hAAAAAAAA;
    int_res = 32'hAAAAAAAA;
    s1_or_s2 = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkMAC

